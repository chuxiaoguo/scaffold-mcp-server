## 🎯 动态模板配置提取方案

基于对当前代码的分析，我设计了一个完整的配置提取方案，将动态模板中的硬编码配置提取到独立的配置文件中。

### 📋 当前硬编码问题分析

通过代码分析，发现以下硬编码问题：

1. **依赖版本硬编码** - 各Builder中直接写死npm包版本
2. **脚本配置硬编码** - package.json scripts直接在代码中定义
3. **配置文件模板硬编码** - tsconfig.json、vite.config.ts等文件内容硬编码
4. **构建工具配置硬编码** - 每个Builder都有大量特定配置
5. **工具差异化配置缺失** - MCP Server、CLI等不同工具无法使用不同配置

### 🏗️ 配置文件结构设计

基于现有的 `configs/` 目录结构，设计分层配置系统：

```
configs/
├── common/                          # 通用配置
│   ├── dependencies/               # 依赖版本管理
│   │   ├── base.json              # 基础依赖版本
│   │   ├── frameworks/            # 框架特定依赖
│   │   │   ├── vue3.json         # Vue3相关依赖
│   │   │   ├── react.json        # React相关依赖
│   │   │   └── electron.json     # Electron相关依赖
│   │   └── builders/              # 构建工具依赖
│   │       ├── vite.json         # Vite相关依赖
│   │       ├── webpack.json      # Webpack相关依赖
│   │       └── umi.json          # UmiJS相关依赖
│   ├── scripts/                   # 脚本配置
│   │   ├── base.json             # 基础脚本
│   │   ├── frameworks/           # 框架特定脚本
│   │   └── builders/             # 构建工具特定脚本
│   ├── file-templates/           # 配置文件模板
│   │   ├── tsconfig/             # TypeScript配置模板
│   │   ├── vite/                 # Vite配置模板
│   │   ├── webpack/              # Webpack配置模板
│   │   └── package/              # package.json模板片段
│   └── builders/                 # 构建器配置
│       ├── vite.json            # Vite构建器配置
│       ├── webpack.json         # Webpack构建器配置
│       ├── electron-vite.json   # Electron Vite构建器配置
│       └── umi.json             # UmiJS构建器配置
├── tools/                        # 工具特定配置
│   ├── mcp-server/              # MCP Server特定配置
│   │   ├── dependencies/        # MCP Server特定依赖覆盖
│   │   ├── scripts/             # MCP Server特定脚本
│   │   └── file-templates/      # MCP Server特定文件模板
│   ├── cli-tool/               # CLI工具特定配置
│   └── vscode-extension/       # VSCode扩展特定配置
└── environments/               # 环境特定配置
    ├── development.json        # 开发环境配置
    ├── production.json         # 生产环境配置
    └── testing.json           # 测试环境配置
```

### 📄 配置文件格式设计

#### 1. 依赖版本配置 (`dependencies/base.json`)
```json
{
  "dependencies": {
    "vue": "^3.4.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "typescript": "^5.3.0",
    "@types/node": "^20.10.0",
    "vite": "^5.0.0",
    "webpack": "^5.89.0"
  },
  "peerDependencies": {
    "node": ">=18.0.0"
  }
}
```

#### 2. 脚本配置 (`scripts/base.json`)
```json
{
  "scripts": {
    "dev": "{{builder_dev_command}}",
    "build": "{{builder_build_command}}",
    "preview": "{{builder_preview_command}}",
    "lint": "eslint src --ext .ts,.tsx,.js,.jsx,.vue",
    "format": "prettier --write src",
    "test": "{{test_runner}}"
  },
  "variables": {
    "builder_dev_command": {
      "vite": "vite",
      "webpack": "webpack serve",
      "umi": "umi dev"
    },
    "builder_build_command": {
      "vite": "{{typescript ? 'tsc && ' : ''}}vite build",
      "webpack": "webpack --mode production",
      "umi": "umi build"
    }
  }
}
```

#### 3. 构建器配置 (`builders/vite.json`)
```json
{
  "name": "vite",
  "dependencies": {
    "extends": ["common/dependencies/base.json"],
    "devDependencies": {
      "vite": "^5.0.0"
    }
  },
  "scripts": {
    "extends": ["common/scripts/base.json"],
    "overrides": {
      "dev": "vite",
      "build": "{{typescript ? 'tsc && ' : ''}}vite build",
      "preview": "vite preview"
    }
  },
  "fileTemplates": {
    "vite.config.ts": "common/file-templates/vite/config.template",
    "index.html": "common/file-templates/vite/index.template"
  },
  "supportedFrameworks": ["vue3", "react"],
  "defaultOptions": {
    "typescript": true,
    "eslint": true,
    "prettier": true
  }
}
```

#### 4. 文件模板 (`file-templates/vite/config.template`)
```typescript
import { defineConfig } from 'vite'
{{#if framework.vue3}}
import vue from '@vitejs/plugin-vue'
{{/if}}
{{#if framework.react}}
import react from '@vitejs/plugin-react'
{{/if}}

export default defineConfig({
  plugins: [
    {{#if framework.vue3}}vue(){{/if}}
    {{#if framework.react}}react(){{/if}}
  ],
  resolve: {
    alias: {
      '@': '/src'
    }
  }
  {{#if additional_config}}
  ,{{additional_config}}
  {{/if}}
})
```

#### 5. 工具特定配置 (`tools/mcp-server/dependencies/overrides.json`)
```json
{
  "devDependencies": {
    "@types/node": "^20.10.0",
    "typescript": "^5.3.0"
  },
  "scripts": {
    "mcp:install": "npm link",
    "mcp:test": "node test-mcp-integration.js"
  },
  "excludeFromBuild": [
    "test-*",
    "*.test.*",
    "examples/"
  ]
}
```

### 🔧 配置加载机制设计

#### 1. 配置继承和合并策略
- **基础配置** → **框架配置** → **构建工具配置** → **工具特定配置** → **环境配置**
- 后加载的配置覆盖先加载的配置
- 支持数组合并、对象深度合并

#### 2. 模板变量系统
- 支持条件渲染：`{{#if typescript}}...{{/if}}`
- 支持变量替换：`{{project_name}}`、`{{framework}}`
- 支持计算表达式：`{{typescript ? 'tsc && ' : ''}}`

#### 3. 配置验证机制
- JSON Schema验证配置文件格式
- 依赖版本兼容性检查
- 模板变量完整性验证

### 🚀 实现步骤

#### 阶段1：配置文件创建
1. 创建基础配置文件结构
2. 从现有Builder代码中提取硬编码配置
3. 按框架和构建工具分类整理配置

#### 阶段2：配置加载器增强
1. 扩展现有的ConfigLoader支持新的配置类型
2. 实现配置继承和合并逻辑
3. 添加模板变量解析功能

#### 阶段3：Builder重构
1. 重构各个Builder类，移除硬编码配置
2. 使用配置加载器获取动态配置
3. 保持向后兼容性

#### 阶段4：工具特定配置
1. 为不同工具（MCP Server、CLI等）创建特定配置
2. 实现工具配置选择逻辑
3. 测试不同工具的配置差异

### 💡 优势

1. **配置集中管理** - 所有配置统一管理，易于维护
2. **工具差异化** - 支持不同工具使用不同配置
3. **版本统一管理** - 依赖版本集中管理，避免版本冲突
4. **模板复用** - 配置文件模板可复用，减少重复代码
5. **易于扩展** - 新增框架或构建工具只需添加配置文件
6. **向后兼容** - 保持现有API不变，渐进式迁移

这个方案将彻底解决动态模板中的硬编码问题，同时为不同工具提供差异化配置支持，大大提升系统的可维护性和扩展性。
        